#include <linux/module.h>#include <linux/kernel.h>#include <linux/fs.h>#include <linux/init.h>#include <linux/delay.h>#include <asm/uaccess.h>#include <asm/irq.h>#include <asm/io.h>#include <asm/arch/regs-gpio.h>#include <asm/hardware.h>#include <linux/proc_fs.h>#define MYLOG_BUF_LEN 1024struct proc_dir_entry *myentry;static char mylog_buf[MYLOG_BUF_LEN];static char tmpbuf[MYLOG_BUF_LEN];//声明一个等待队列头static DECLARE_WAIT_QUEUE_HEAD(mymsg_waitq);static int  mylog_r =0;static int  mylog_w =0;static int mylog_r_for_read = 0;//用这个临时的变量来替代mylog_rstatic int ringbuffempty_for_read(void){//*返回0:表示不空//      返回1:表示空 因为 == 这是一个判断的条件如果条件为真则返回1	return (mylog_r_for_read == mylog_w);//	mylog_w和mylog_r相等肯定为空}static int ringbuffempty(void){//*返回0:表示不空//      返回1:表示空 因为 == 这是一个判断的条件如果条件为真则返回1	return (mylog_r == mylog_w);//	mylog_w和mylog_r相等肯定为空}static int ringbufffull(void)//当要写入的下一个位置是读地位置表示肯定满了{//返回0:表示不满      //返回1:表示满 	return ((mylog_w + 1)% MYLOG_BUF_LEN == mylog_r);}static void ringbufffputc(char c)//放入一个字节{	if(ringbufffull())//满了丢弃一个数据也就是相当已经读了所以r向下移	{		mylog_r = (mylog_r +1) % MYLOG_BUF_LEN;		//如果一直驱动调用myprintk 导致write 覆盖 mylog_r的时候我么要将		//mylog_r 和mylog_r_for_read 保持一致		if((mylog_r_for_read +1) % MYLOG_BUF_LEN == mylog_r)		{			mylog_r_for_read = mylog_r;		}	}	mylog_buf[mylog_w] = c;	mylog_w = (mylog_w + 1) % MYLOG_BUF_LEN;	//因为我们在环形缓冲区为空的时候休眠了有数据写入就唤醒等待的队列	wake_up_interruptible(&mymsg_waitq);   /* 唤醒队列*/	}static int ringbuffgetc_for_read(char *p){	if (ringbuffempty_for_read())//空的返回0	{		return 0;	}	*p = mylog_buf[mylog_r_for_read];	mylog_r_for_read = (mylog_r_for_read +1) % MYLOG_BUF_LEN;	return 1;	}static int ringbuffgetc(char *p)//得到一个字节{	if (ringbuffempty())//空的返回0	{		return 0;	}	*p = mylog_buf[mylog_r];	mylog_r = (mylog_r +1) % MYLOG_BUF_LEN;	return 1;}//基于sprintf实现int myprintk(const char *fmt, ...)// ...可变信息{	va_list args;	int i;	int j;	va_start(args, fmt);	//i=vsprintf(buf,fmt,args)	//视频用的是vsnprintf	i=vsprintf(tmpbuf,fmt,args);//mylog_tmpbuf 存放的打出的数据	va_end(args);	for(j =0;j < i;j++ )//是j < i	{		ringbufffputc(tmpbuf[j]);//将我们的数据放到环形缓冲区	}	return i;}static ssize_t mymsg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos){	//printk("mymsg_read\n");	/*我们就是将mykogbuf内容copy_to_user return */	int  cnt;	int i =0;	char c;	int error =0;	//cnt = min(1024,count);	//参考kmsg_read函数	//非阻塞而且环形缓冲区空立刻返回	if ((file->f_flags & O_NONBLOCK) && ringbuffempty_for_read())		return -EAGAIN;	//第二个参数是conditon条件不成立休眠.就是等待直到不空	//进入休眠了神魔时候唤醒呢，的去等待队列唤醒，。没有数据就休眠	error = wait_event_interruptible(mymsg_waitq,!ringbuffempty_for_read());	//__put_user跟copy_to_user基本一致	while (!error && (ringbuffgetc_for_read(&c)) && i < count) {			error = __put_user(c,buf);/*传给应用空间*/			buf++;			i++;					}	if(!error)		error = i;	return error;//有错误的话返回错误，没有的话返回I}static int mymsg_open(struct inode *inode, struct file *file){	mylog_r_for_read = mylog_r;//每次cat 的时候都会open 我们将mylog_r_for_read每次都拉到开头	return 0;}const struct file_operations proc_mymsg_operations = {		.open = mymsg_open,		.read = mymsg_read,};	static int mymsg_init(void){	//在proc/下生成一个条目	myentry = create_proc_entry("mymsg", S_IRUSR, &proc_root);	if (myentry)		myentry->proc_fops = &proc_mymsg_operations;	return 0;}static void mymsg_exit(void){	remove_proc_entry("mymsg", &proc_root);/*一般来说有create_proc_entry肯定对应有移除*/}module_init(mymsg_init);module_exit(mymsg_exit);EXPORT_SYMBOL(myprintk);//我们的myprink要给别人用所以要加上EXPORT_SYMBOLMODULE_LICENSE("GPL");